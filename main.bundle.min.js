function checkrowdif(row, rotate) { let row0 = deepClone(row[0]); let row1; let difY; let y0, y1, h1, h0, yt; let asc = rotate === 90 || rotate === 180 ? true : false; let ascY = row['ascY']; let dirY = ascY ? 1 : -1; let row01; let rowMerged = []; for(let i = 1; i < row.length; i += 1){ row1 = deepClone(row[i]); difY = (row0.y - row1.t) * dirY; if (difY >= 0) { row01 = mergerow(row0, row1, rotate); if (row01) { row01['y'] = (row0.y + row1.y) / 2; rowMerged.push(row01); i += 1; row0 = i < row.length ? deepClone(row[i]) : { }; } else { rowMerged.push(row0); row0 = row1; } } else { rowMerged.push(row0); row0 = row1; } } if (row0) rowMerged.push(row0); return rowMerged; } function mergerow(row0, row1, rotate) { let success = false; let str0; let str1; let newc = []; let newi; let ascX = row0['ascX']; let dirY = row0['ascY'] ? 1 : -1; let difY = (row0.y - row1.t) * dirY; let lgth = Math.max(row1.length, row0.length); for(let i = 0; i < lgth; i += 1){ str0 = row0[i]?.str; str1 = row1[i]?.str; difY = row0[i] && row1[i] ? (row0[i].y - row1[i].t) * dirY : undefined; if (str0 && str1) { success = false; break; } else { newi = str0 ? row0[i] : row1[i]; if (newi && newc[newc.length - 1] && newc[newc.length - 1].r > newi.x) { success = false; } else if (difY < 0) { success = false; } else { newc.push(newi); success = true; } } } if (success) { return newc; } else { return false; } } function deepClone(o) { let copied0 = JSON.parse(JSON.stringify({ ...o })); let copied1 = []; for(let i in copied0){ copied1[i] = copied0[i]; } return copied1; } function getYinRow(row) { return row['y']; } const ntoRight = (obj, clr, i, dirX, xMin, xMax)=>{ let { x , r , str } = obj; const { col , left , right } = clr; x = parseFloat(x.toFixed(1)); r = parseFloat(r.toFixed(1)); if (left.has(x)) { let getx = left.get(x); console.log(`${obj.str} is found in left: ${getx} shift ${getx - i} from current position`); return getx - i; } if (right.has(r)) { let getr = right.get(r); console.log(`${obj.str} is found in right: ${getr} shift ${getr - i} from current position`); return getr - i; } if (x * dirX > col[i].r * dirX) { console.log(`${obj.str} is might be on the right of cell ${i}`); let tmp = findIn({ col: col, i: i, x: x, r: r, dirX: dirX, xMin: xMin, xMax: xMax }) - i; return tmp; } return 0; }; const findIn = (par)=>{ const { col , x , r , dirX , xMin , xMax } = par; let { i } = par; let ix, ir; let difx0 = -1, difx1 = -1; let difr0 = -1, difr1 = -1; let difxr, difxx; let difrx, difrr; let xdone = false; let rdone = false; let iscontinue = true; let xSign0, rSign0; let xSign1, rSign1; do { if (!xdone) { difxr = (x - (col[i - 1]?.r ?? xMin)) * dirX; xSign1 = Math.sign(difxr); if (xSign0 && xSign0 * xSign1 < 0) { ix = i - 1; xdone = true; difxx = (x - col[ix].x) * dirX; console.log(`difxr: ${difxr} and difxx: ${difxx} found in ${ix}`); } else { xSign0 = xSign1; } } if (xdone) { difrx = ((col[i + 1]?.x ?? xMax) - r) * dirX; rSign1 = Math.sign(difrx); if (rSign0 && rSign0 * rSign1 < 0) { ir = i; rdone = true; difrr = (col[ir].r - r) * dirX; console.log(`difrx: ${difrx} and difrrr: ${difrr} found in ${ir}`); } else { rSign0 = rSign1; } } else { } i += 1; if (rdone) iscontinue = false; if (i === col.length && !ir) { ir = i - 1; iscontinue = false; } }while (iscontinue) difrr = (col[ir].r - r) * dirX; if (difxx < difrr) { console.log(`the result are in left difxx: ${difxx} < difrr: ${difrr}`); return ix; } else { return ir; } return ir; }; function arrangeCol(rows, clr) { if (clr === undefined || clr === null) { console.log(`clr is undefined, end`); return; } const { col , left , right } = clr; let ascX = rows['ascX']; let ascY = rows['ascY']; let dirX = ascX ? 1 : -1; let dirY = ascY ? 1 : -1; rows.sort((a, b)=>a.length - b.length ); console.log(`rows are sorted from smaller to larget, re-arrangment are from small to large`); for(let i = 0; i < rows.length; i += 1){ if (rows[i].length === col.length) { console.log(`length are the same no need to re-arrange then continue to the next iteration`); continue; } for(let j = 0; j < col.length; j += 1){ if (j > rows[i].length - 1) { console.log(`${j} are beyond rows[${i}].length-1: ${rows[i].length - 1}, break the loop`); break; } if (rows[i][j] === undefined || rows[i][j] === "na") { console.log(`rows[${i}][${j}] is undefined or na, continue to next`); continue; } if (rows[i][j].str === "" || rows[i][j].str === " ") { console.log(`rows[${i}][${j}] is empty string or white space, continue to next`); rows[i].splice(j, 1); j -= 1; continue; } let nShift = ntoRight(rows[i][j], clr, j, dirX, rows['xMin'], rows['xMax']); if (nShift === 0) { continue; } else { rows[i].splice(j, 0, ...Array(nShift)); console.log(`rows[${i}] is shifted ${nShift} to the right, re-arranged done `); j += nShift - 1; } } } rows.sort((a, b)=>{ let yb = getYinRow(b); let ya = getYinRow(a); return (ya - yb) * dirY; }); } const diffXTol = -2.5; function findYinRow(item, row) { for(let r = 0; r < row.length; r += 1){ let diffY = Math.abs(row[r]['y'] - item.y); if (diffY <= 1) { return r; break; } } return 'NotFound'; } function joinItem(rowr, item) { let dirX = item.ascX ? 1 : -1; let prevItem = rowr[0]; let currItem; let difX; let joinRow = []; joinRow['y'] = rowr['y']; joinRow['t'] = rowr['t']; for(let i = 1; i < rowr.length; i += 1){ currItem = rowr[i]; difX = (prevItem.r - currItem.x) * dirX; if (difX > 0) { prevItem.str = prevItem.str + currItem.str; prevItem.r = prevItem.r + currItem.width * dirX; prevItem.width = (prevItem.r - prevItem.x) * dirX; } else if (difX > diffXTol) { prevItem.str = prevItem.str + currItem.str; prevItem.r = currItem.r; prevItem.width = (currItem.r - prevItem.x) * dirX; } else { joinRow.push(prevItem); prevItem = currItem; } } joinRow.push(prevItem); return joinRow; } function pushitemtorow(item, row) { let r; let ascX; let dirX; if (row.length === 0) { row[0] = []; row[0].push(item); row[0]['y'] = item.y; row[0]['t'] = item.t; return; } r = findYinRow(item, row); if (r === 'NotFound') { row.push([ item ]); row[row.length - 1]['y'] = item.y; row[row.length - 1]['t'] = item.t; } else { ascX = row[r]['ascX']; dirX = ascX ? 1 : -1; row[r].push(item); row[r].sort((a, b)=>(b.x - a.x) * dirX ); row[r] = joinItem(row[r], item); } } function fillcol(row, xMax, xMin) { let dcol = []; dcol['xMax'] = xMax; dcol['xMin'] = xMin; for(let i = 0; i < row.length; i += 1){ let str = row[i].str; if (str === "" || str === " ") { continue; console.log(`row[${i}] contains space white, excluded`); } let xF1 = parseFloat(row[i].x.toFixed(1)); let rF1 = parseFloat(row[i].r.toFixed(1)); dcol.push({ left: [ xF1 ], x: xF1, r: rF1, right: [ rF1 ] }); } return dcol; } const updatecol = (l, s, dirX, left, right)=>{ if (s === undefined || s.length === 0) { console.log(`s is undefined or has no member to evaluate or merge, return to mergecol`); return; } for(let i = 0; i < l.length; i += 1){ if (i >= s.length) break; if (s[i] === 'na' || s[i] === undefined) { console.log(`s[${i}] is undefined or has no member to evaluate or merge, continue to the next iteration`); continue; } if (l[i].x !== s[i].x) { let tmp = Math.min(l[i].x * dirX, s[i].x * dirX); if (!tmp) { console.log(`something wrong with ${l[i]} and ${s[i]} we need to bypass this`); continue; } l[i].x = tmp; let indexOfx = l[i]['left'].indexOf(tmp); if (indexOfx === -1) { l[i]['left'].push(l[i].x); } else { if (!left.has(tmp)) { console.log(`save the new left alignment sign in ${i} with value of x: ${tmp} to the left Map`); left.set(tmp, i); } } } else { let x0 = l[i].x; let x1 = s[i].x; if (!left.has(x0)) { console.log(`save the new left alignment sign in ${i} with value of x: ${x0} to the left Map`); left.set(x0, i); } } if (l[i].r !== s[i].r && s[i].r * dirX < (l?.[i + 1]?.x ?? l['xMax']) * dirX) { let tmp = Math.max(l[i].r * dirX, s[i].r * dirX); if (!tmp) { console.log(`something wrong with ${l[i]} and ${s[i]} we need to bypass this`); continue; } l[i].r = tmp; let indexOfr = l[i]['right'].indexOf(tmp); if (indexOfr === -1) { l[i]['right'].push(s[i].r); } else { if (!right.has(tmp)) { console.log(`save the new right alignment sign in ${i} with value of r: ${tmp} to the right Map`); right.set(tmp, i); } } } else { let r0 = l[i].r; let r1 = s[i].r; if (!right.has(r0)) { console.log(`save the new right alignment sign in ${i} with value of r: ${r0} to the right Map`); right.set(r0, i); } } } }; const copyArrayLike = (obj)=>{ let copied = []; for (let [k, v] of Object.entries(obj)){ copied[k] = v; } return copied; }; function mergecol(longcol, shortcol, dirX, left, right) { if (shortcol === undefined || shortcol.length === 0) { console.log(`shortcol is undefined or has no member to evaluate or merge, return to `); return longcol; } let length = longcol.length; for(let i = 0; i < length; i += 1){ if (i > shortcol.length - 1) { console.log(`index ${i} > shortcol[i].length-1 ${shortcol.length - 1} need to break`); break; } if (shortcol[i] === undefined) { console.log(`shortcol member in ${i} is undefined then continue to the next iteration`); continue; } if (longcol[i] && shortcol[i].x * dirX > longcol[i].r * dirX) { shortcol.splice(i, 0, "na"); if (shortcol.length > length) { length = shortcol.length; console.log(`shortcol are getting longer after splice then add 1 iteration into length`); } continue; } else if (!longcol[i]) { longcol[i] = copyArrayLike(shortcol[i]); console.log(`copying shortcol in ${i} to longcol after adjusting length of shortcol`); continue; } } updatecol(longcol, shortcol, dirX, left, right); return longcol; } function inspectCol(rows) { let dirX = rows['ascX'] ? 1 : -1; let col0 = []; let col1 = []; let left = new Map(); let right = new Map(); rows.sort((a, b)=>b.length - a.length ); console.log(`rows sorted from the longest to shortest`); let length0 = 0, length1 = 0; for(let i = 0; i < rows.length; i += 1){ col0 = fillcol(rows[i], rows['xMax'], rows['xMin']); length0 = col0.length; if (length0 === 0) { continue; console.log(`length 0 in ${rows[i]} is not eligible to evaluate`); } if (length1 === 0) { col1 = copyArrayLike(col0); length1 = length0; console.log(`preparing for new pairs for col0 by copying col0 to col1 in iteration ${i}`); continue; } else if (length1 >= length0) { console.log(`length col1 are ${length1} >= length of col0: ${length0} in index: ${i} before merge process`); col1 = mergecol(col1, col0, dirX, left, right); console.log(`length col1 are ${col1.length} >= length of col0: ${col0.length} in index: ${i} after merge process`); } else if (length0 > length1) { console.log(`length col1 are ${length1} < length of col0: ${length0} in index: ${i}before merge process`); col1 = mergecol(col0, col1, dirX, left, right); console.log(`length col1 are ${col1.length} < length of col0: ${col0.length} in index: ${i}after merge process`); } } return { col: col1, left: left, right: right }; } function _getX(item) { if (item && Array.isArray(item.transform)) { return item.transform[4] || -1; } return -1; } function _getY(item) { if (item && Array.isArray(item.transform)) { return item.transform[5] || -1; } return -1; } function parsepdf(items, rotate, view) { let get_X = _getX; let get_Y = _getY; if (rotate === 90 || rotate === 270) { get_X = _getY; get_Y = _getX; } let ascX = rotate === 0 || rotate === 90 ? true : false; let ascY = rotate === 90 || rotate === 180 ? true : false; let row = []; let col = []; let _left = []; let _right = []; row['ascX'] = ascX; row['ascY'] = ascY; row['xMax'] = col['xMax'] = ascX ? view?.[2] : 0; row['yMax'] = col['yMax'] = ascY ? 0 : view?.[3]; row['xMin'] = col['xMin'] = ascX ? 0 : view?.[2]; row['yMin'] = col['yMin'] = ascY ? view?.[3] : 0; for (let item of items){ item.x = get_X(item); item.y = Math.round(get_Y(item)); item.t = item.y + item.height * (ascY ? -1 : 1); item.r = item.x + item.width * (ascX ? 1 : -1); item.ascX = ascX; item.ascY = ascY; pushitemtorow(item, row); } let clr = inspectCol(row); arrangeCol(row, clr); return checkrowdif(row, rotate).filter((e)=>e.length > 0 ); return row; } async function loadPdf1(file, pdfjsLib, pageNum, pdf2base64, atob) { const binarypdf = atob(await pdf2base64(file)); let loadingTask = await pdfjsLib.getDocument({ data: binarypdf }); let pdf = await function() { return loadingTask.promise; }(); let numPages = pdf._pdfInfo.numPages; let Attachements = await function() { return pdf.getAttachments(); }(); let data = await function() { return pdf.getData(); }(); let Page = await function() { return pdf.getPage(pageNum); }(); let Destinations = await function() { return pdf.getDestinations(); }(); let Metadata = await function() { return pdf.getMetadata(); }(); let Outline = await function() { return pdf.getOutline(); }(); let PageLayout = await function() { return pdf.getPageLayout(); }(); let annotationStorage = pdf.annotationStorage; let textContent = await function() { return Page.getTextContent(); }(); let rotate = Page._pageInfo.rotate; return parsepdf(textContent.items, rotate, Page._pageInfo.view).map((e)=>e.map((f)=>{ return f ? f.str : ''; }) ); return Page._pageInfo; } export { loadPdf1 as loadPdf };