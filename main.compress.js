function checkrowdif(t,e){let n,r,o=deepClone(t[0]);const i=t.ascY?1:-1;let s;const a=[];for(let l=1;l<t.length;l+=1)n=deepClone(t[l]),r=(o.y-n.t)*i,r>=0?(s=mergerow(o,n,e),s?(s.y=(o.y+n.y)/2,a.push(s),l+=1,o=l<t.length?deepClone(t[l]):{}):(a.push(o),o=n)):(a.push(o),o=n);return o&&a.push(o),a}function mergerow(t,e,n){let r,o,i=!1;const s=[];let a;const l=t.ascY?1:-1;let c=(t.y-e.t)*l;const f=Math.max(e.length,t.length);for(let n=0;n<f;n+=1){if(r=t[n]?.str,o=e[n]?.str,c=t[n]&&e[n]?(t[n].y-e[n].t)*l:void 0,r&&o){i=!1;break}a=r?t[n]:e[n],a&&s[s.length-1]&&s[s.length-1].r>a.x||c<0?i=!1:(s.push(a),i=!0)}return!!i&&s}function deepClone(t){const e=JSON.parse(JSON.stringify({...t})),n=[];for(const t in e)n[t]=e[t];return n}function getYinRow(t){return t.y}const ntoRight=(t,e,n,r,o,i)=>{let{x:s,r:a,_str:l}=t;const{col:c,left:f,right:g}=e;if(s=parseFloat(s.toFixed(1)),a=parseFloat(a.toFixed(1)),f.has(s)){return f.get(s)-n}if(g.has(a)){return g.get(a)-n}if(s*r>c[n].r*r){return findIn({col:c,i:n,x:s,r:a,dirX:r,xMin:o,xMax:i})-n}return 0},findIn=t=>{const{col:e,x:n,r:r,dirX:o,xMin:i,xMax:s}=t;let a,l,c,f,g,h,u,p,x,d,{i:y}=t,w=!1,M=!1,m=!0;do{w||(c=(n-(e[y-1]?.r??i))*o,x=Math.sign(c),u&&u*x<0?(a=y-1,w=!0,f=(n-e[a].x)*o):u=x),w&&(g=((e[y+1]?.x??s)-r)*o,d=Math.sign(g),p&&p*d<0?(l=y,M=!0,h=(e[l].r-r)*o):p=d),y+=1,M&&(m=!1),y!==e.length||l||(l=y-1,m=!1)}while(m);return h=(e[l].r-r)*o,f<h?a:l};function arrangeCol(t,e){if(null==e)return;const{col:n,_left:r,_right:o}=e,i=t.ascX?1:-1,s=t.ascY?1:-1;t.sort(((t,e)=>t.length-e.length));for(let r=0;r<t.length;r+=1)if(t[r].length!==n.length)for(let o=0;o<n.length&&!(o>t[r].length-1);o+=1){if(void 0===t[r][o]||"na"===t[r][o])continue;if(""===t[r][o].str||" "===t[r][o].str){t[r].splice(o,1),o-=1;continue}const n=ntoRight(t[r][o],e,o,i,t.xMin,t.xMax);0!==n&&(t[r].splice(o,0,...Array(n)),o+=n-1)}t.sort(((t,e)=>{const n=getYinRow(e);return(getYinRow(t)-n)*s}))}const diffXTol=-2.5;function findYinRow(t,e){for(let n=0;n<e.length;n+=1){if(Math.abs(e[n].y-t.y)<=1)return n}return"NotFound"}function joinItem(t,e){const n=e.ascX?1:-1;let r,o,i=t[0];const s=[];s.y=t.y,s.t=t.t;for(let e=1;e<t.length;e+=1)r=t[e],o=(i.r-r.x)*n,o>0?(i.str=i.str+r.str,i.r=i.r+r.width*n,i.width=(i.r-i.x)*n):o>-2.5?(i.str=i.str+r.str,i.r=r.r,i.width=(r.r-i.x)*n):(s.push(i),i=r);return s.push(i),s}function pushitemtorow(t,e){let n,r;if(0===e.length)return e[0]=[],e[0].push(t),e[0].y=t.y,void(e[0].t=t.t);const o=findYinRow(t,e);"NotFound"===o?(e.push([t]),e[e.length-1].y=t.y,e[e.length-1].t=t.t):(n=e[o].ascX,r=n?1:-1,e[o].push(t),e[o].sort(((t,e)=>(e.x-t.x)*r)),e[o]=joinItem(e[o],t))}function fillcol(t,e,n){const r=[];r.xMax=e,r.xMin=n;for(let e=0;e<t.length;e+=1){const n=t[e].str;if(""===n||" "===n)continue;const o=parseFloat(t[e].x.toFixed(1)),i=parseFloat(t[e].r.toFixed(1));r.push({left:[o],x:o,r:i,right:[i]})}return r}const updatecol=(t,e,n,r,o)=>{if(void 0!==e&&0!==e.length)for(let i=0;i<t.length&&!(i>=e.length);i+=1)if("na"!==e[i]&&void 0!==e[i]){if(t[i].x!==e[i].x){const o=Math.min(t[i].x*n,e[i].x*n);if(!o)continue;t[i].x=o;-1===t[i].left.indexOf(o)?t[i].left.push(t[i].x):r.has(o)||r.set(o,i)}else{const n=t[i].x;e[i].x;r.has(n)||r.set(n,i)}if(t[i].r!==e[i].r&&e[i].r*n<(t?.[i+1]?.x??t.xMax)*n){const r=Math.max(t[i].r*n,e[i].r*n);if(!r)continue;t[i].r=r;-1===t[i].right.indexOf(r)?t[i].right.push(e[i].r):o.has(r)||o.set(r,i)}else{const n=t[i].r;e[i].r;o.has(n)||o.set(n,i)}}},copyArrayLike=t=>{const e=[];for(const[n,r]of Object.entries(t))e[n]=r;return e};function mergecol(t,e,n,r,o){if(void 0===e||0===e.length)return t;let i=t.length;for(let r=0;r<i&&!(r>e.length-1);r+=1)void 0!==e[r]&&(t[r]&&e[r].x*n>t[r].r*n?(e.splice(r,0,"na"),e.length>i&&(i=e.length)):t[r]||(t[r]=copyArrayLike(e[r])));return updatecol(t,e,n,r,o),t}function inspectCol(t){const e=t.ascX?1:-1;let n=[],r=[];const o=new Map,i=new Map;t.sort(((t,e)=>e.length-t.length));let s=0,a=0;for(let l=0;l<t.length;l+=1)n=fillcol(t[l],t.xMax,t.xMin),s=n.length,0!==s&&(0!==a?a>=s?r=mergecol(r,n,e,o,i):s>a&&(r=mergecol(n,r,e,o,i)):(r=copyArrayLike(n),a=s));return{col:r,left:o,right:i}}function _getX(t){return t&&Array.isArray(t.transform)&&t.transform[4]||-1}function _getY(t){return t&&Array.isArray(t.transform)&&t.transform[5]||-1}function parsepdf(t,e,n){let r=_getX,o=_getY;90!==e&&270!==e||(r=_getY,o=_getX);const i=0===e||90===e,s=90===e||180===e,a=[],l=[];a.ascX=i,a.ascY=s,a.xMax=l.xMax=i?n?.[2]:0,a.yMax=l.yMax=s?0:n?.[3],a.xMin=l.xMin=i?0:n?.[2],a.yMin=l.yMin=s?n?.[3]:0;for(const e of t)""!==e.str&&" "!==e.str&&(e.x=r(e),e.y=Math.round(o(e)),e.t=e.y+e.height*(s?-1:1),e.r=e.x+e.width*(i?1:-1),e.ascX=i,e.ascY=s,pushitemtorow(e,a));return arrangeCol(a,inspectCol(a)),checkrowdif(a,e).filter((t=>t.length>0))}async function loadpdf1(t,e,n,r,o){const i=o(await r(t)),s=await e.getDocument({data:i}),a=await s.promise,l=await a.getPage(n),c=await l.getTextContent(),f=l._pageInfo.rotate;return parsepdf(c.items,f,l._pageInfo.view).map((t=>t.map((t=>t?t.str:""))))}async function loadpdfInClient1(t,e){const n=await e.getDocument({data:t});return await n.promise}async function parsepdfpage1(t,e){const n=await t.getPage(e);return parsepdf((await n.getTextContent()).items,n._pageInfo.rotate,n._pageInfo.view).map((t=>t.map((t=>t?t.str:""))))}export{loadpdf1 as loadpdf,loadpdfInClient1 as loadpdfInClient,parsepdfpage1 as parsepdfpage};