function checkrowdif(row,rotate){let row1,difY,row01,row0=deepClone(row[0]),dirY=row.ascY?1:-1,rowMerged=[];for(let i=1;i<row.length;i+=1)row1=deepClone(row[i]),difY=(row0.y-row1.t)*dirY,difY>=0?(row01=mergerow(row0,row1,rotate),row01?(row01.y=(row0.y+row1.y)/2,rowMerged.push(row01),i+=1,row0=i<row.length?deepClone(row[i]):{}):(rowMerged.push(row0),row0=row1)):(rowMerged.push(row0),row0=row1);return row0&&rowMerged.push(row0),rowMerged}function mergerow(row0,row1,rotate){let str0,str1,newi,success=!1,newc=[],dirY=(row0.ascX,row0.ascY?1:-1),difY=(row0.y-row1.t)*dirY,lgth=Math.max(row1.length,row0.length);for(let i=0;i<lgth;i+=1){if(str0=row0[i]?.str,str1=row1[i]?.str,difY=row0[i]&&row1[i]?(row0[i].y-row1[i].t)*dirY:void 0,str0&&str1){success=!1;break}newi=str0?row0[i]:row1[i],newi&&newc[newc.length-1]&&newc[newc.length-1].r>newi.x||difY<0?success=!1:(newc.push(newi),success=!0)}return!!success&&newc}function deepClone(o){let copied0=JSON.parse(JSON.stringify({...o})),copied1=[];for(let i in copied0)copied1[i]=copied0[i];return copied1}function getYinRow(row){return row.y}const ntoRight=(obj,clr,i,dirX,xMin,xMax)=>{let{x:x,r:r,str:str}=obj;const{col:col,left:left,right:right}=clr;if(x=parseFloat(x.toFixed(1)),r=parseFloat(r.toFixed(1)),left.has(x)){return left.get(x)-i}if(right.has(r)){return right.get(r)-i}if(x*dirX>col[i].r*dirX){return findIn({col:col,i:i,x:x,r:r,dirX:dirX,xMin:xMin,xMax:xMax})-i}return 0},findIn=par=>{const{col:col,x:x,r:r,dirX:dirX,xMin:xMin,xMax:xMax}=par;let ix,ir,difxr,difxx,difrx,difrr,xSign0,rSign0,xSign1,rSign1,{i:i}=par,xdone=!1,rdone=!1,iscontinue=!0;do{xdone||(difxr=(x-(col[i-1]?.r??xMin))*dirX,xSign1=Math.sign(difxr),xSign0&&xSign0*xSign1<0?(ix=i-1,xdone=!0,difxx=(x-col[ix].x)*dirX):xSign0=xSign1),xdone&&(difrx=((col[i+1]?.x??xMax)-r)*dirX,rSign1=Math.sign(difrx),rSign0&&rSign0*rSign1<0?(ir=i,rdone=!0,difrr=(col[ir].r-r)*dirX):rSign0=rSign1),i+=1,rdone&&(iscontinue=!1),i!==col.length||ir||(ir=i-1,iscontinue=!1)}while(iscontinue);return difrr=(col[ir].r-r)*dirX,difxx<difrr?ix:ir};function arrangeCol(rows,clr){if(null==clr)return;const{col:col,left:left,right:right}=clr;let dirX=rows.ascX?1:-1,dirY=rows.ascY?1:-1;rows.sort(((a,b)=>a.length-b.length));for(let i=0;i<rows.length;i+=1)if(rows[i].length!==col.length)for(let j=0;j<col.length&&!(j>rows[i].length-1);j+=1){if(void 0===rows[i][j]||"na"===rows[i][j])continue;if(""===rows[i][j].str||" "===rows[i][j].str){rows[i].splice(j,1),j-=1;continue}let nShift=ntoRight(rows[i][j],clr,j,dirX,rows.xMin,rows.xMax);0!==nShift&&(rows[i].splice(j,0,...Array(nShift)),j+=nShift-1)}rows.sort(((a,b)=>{let yb=getYinRow(b);return(getYinRow(a)-yb)*dirY}))}const diffXTol=-2.5;function findYinRow(item,row){for(let r=0;r<row.length;r+=1){if(Math.abs(row[r].y-item.y)<=1)return r}return"NotFound"}function joinItem(rowr,item){let currItem,difX,dirX=item.ascX?1:-1,prevItem=rowr[0],joinRow=[];joinRow.y=rowr.y,joinRow.t=rowr.t;for(let i=1;i<rowr.length;i+=1)currItem=rowr[i],difX=(prevItem.r-currItem.x)*dirX,difX>0?(prevItem.str=prevItem.str+currItem.str,prevItem.r=prevItem.r+currItem.width*dirX,prevItem.width=(prevItem.r-prevItem.x)*dirX):difX>-2.5?(prevItem.str=prevItem.str+currItem.str,prevItem.r=currItem.r,prevItem.width=(currItem.r-prevItem.x)*dirX):(joinRow.push(prevItem),prevItem=currItem);return joinRow.push(prevItem),joinRow}function pushitemtorow(item,row){let r,ascX,dirX;if(0===row.length)return row[0]=[],row[0].push(item),row[0].y=item.y,void(row[0].t=item.t);r=findYinRow(item,row),"NotFound"===r?(row.push([item]),row[row.length-1].y=item.y,row[row.length-1].t=item.t):(ascX=row[r].ascX,dirX=ascX?1:-1,row[r].push(item),row[r].sort(((a,b)=>(b.x-a.x)*dirX)),row[r]=joinItem(row[r],item))}function fillcol(row,xMax,xMin){let dcol=[];dcol.xMax=xMax,dcol.xMin=xMin;for(let i=0;i<row.length;i+=1){let str=row[i].str;if(""===str||" "===str)continue;let xF1=parseFloat(row[i].x.toFixed(1)),rF1=parseFloat(row[i].r.toFixed(1));dcol.push({left:[xF1],x:xF1,r:rF1,right:[rF1]})}return dcol}const updatecol=(l,s,dirX,left,right)=>{if(void 0!==s&&0!==s.length)for(let i=0;i<l.length&&!(i>=s.length);i+=1)if("na"!==s[i]&&void 0!==s[i]){if(l[i].x!==s[i].x){let tmp=Math.min(l[i].x*dirX,s[i].x*dirX);if(!tmp)continue;l[i].x=tmp,-1===l[i].left.indexOf(tmp)?l[i].left.push(l[i].x):left.has(tmp)||left.set(tmp,i)}else{let x0=l[i].x;s[i].x;left.has(x0)||left.set(x0,i)}if(l[i].r!==s[i].r&&s[i].r*dirX<(l?.[i+1]?.x??l.xMax)*dirX){let tmp=Math.max(l[i].r*dirX,s[i].r*dirX);if(!tmp)continue;l[i].r=tmp,-1===l[i].right.indexOf(tmp)?l[i].right.push(s[i].r):right.has(tmp)||right.set(tmp,i)}else{let r0=l[i].r;s[i].r;right.has(r0)||right.set(r0,i)}}},copyArrayLike=obj=>{let copied=[];for(let[k,v]of Object.entries(obj))copied[k]=v;return copied};function mergecol(longcol,shortcol,dirX,left,right){if(void 0===shortcol||0===shortcol.length)return longcol;let length=longcol.length;for(let i=0;i<length&&!(i>shortcol.length-1);i+=1)void 0!==shortcol[i]&&(longcol[i]&&shortcol[i].x*dirX>longcol[i].r*dirX?(shortcol.splice(i,0,"na"),shortcol.length>length&&(length=shortcol.length)):longcol[i]||(longcol[i]=copyArrayLike(shortcol[i])));return updatecol(longcol,shortcol,dirX,left,right),longcol}function inspectCol(rows){let dirX=rows.ascX?1:-1,col0=[],col1=[],left=new Map,right=new Map;rows.sort(((a,b)=>b.length-a.length));let length0=0,length1=0;for(let i=0;i<rows.length;i+=1)col0=fillcol(rows[i],rows.xMax,rows.xMin),length0=col0.length,0!==length0&&(0!==length1?length1>=length0?col1=mergecol(col1,col0,dirX,left,right):length0>length1&&(col1=mergecol(col0,col1,dirX,left,right)):(col1=copyArrayLike(col0),length1=length0));return{col:col1,left:left,right:right}}function _getX(item){return item&&Array.isArray(item.transform)&&item.transform[4]||-1}function _getY(item){return item&&Array.isArray(item.transform)&&item.transform[5]||-1}function parsepdf(items,rotate,view){let get_X=_getX,get_Y=_getY;90!==rotate&&270!==rotate||(get_X=_getY,get_Y=_getX);let ascX=0===rotate||90===rotate,ascY=90===rotate||180===rotate,row=[],col=[];row.ascX=ascX,row.ascY=ascY,row.xMax=col.xMax=ascX?view?.[2]:0,row.yMax=col.yMax=ascY?0:view?.[3],row.xMin=col.xMin=ascX?0:view?.[2],row.yMin=col.yMin=ascY?view?.[3]:0;for(let item of items)item.x=get_X(item),item.y=Math.round(get_Y(item)),item.t=item.y+item.height*(ascY?-1:1),item.r=item.x+item.width*(ascX?1:-1),item.ascX=ascX,item.ascY=ascY,pushitemtorow(item,row);return arrangeCol(row,inspectCol(row)),checkrowdif(row,rotate).filter((e=>e.length>0))}async function loadpdf1(file,pdfjsLib,pageNum,pdf2base64,atob){const binarypdf=atob(await pdf2base64(file));let loadingTask=await pdfjsLib.getDocument({data:binarypdf}),pdf=await loadingTask.promise,Page=(pdf._pdfInfo.numPages,await pdf.getAttachments(),await pdf.getData(),await pdf.getPage(pageNum)),textContent=(await pdf.getDestinations(),await pdf.getMetadata(),await pdf.getOutline(),await pdf.getPageLayout(),pdf.annotationStorage,await Page.getTextContent()),rotate=Page._pageInfo.rotate;return parsepdf(textContent.items,rotate,Page._pageInfo.view).map((e=>e.map((f=>f?f.str:""))))}async function loadpdfInClient1(binary,pdfjsLib,pageNum){let loadingTask=await pdfjsLib.getDocument({data:binary}),pdf=await loadingTask.promise,Page=await pdf.getPage(pageNum),textContent=await Page.getTextContent(),rotate=Page._pageInfo.rotate;return parsepdf(textContent.items,rotate,Page._pageInfo.view).map((e=>e.map((f=>f?f.str:""))))}export{loadpdf1 as loadpdf,loadpdfInClient1 as loadpdfInClient};