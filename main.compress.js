function checkrowdif(e,t){let o,n,r,l=deepClone(e[0]),i=e.ascY?1:-1,s=[];for(let a=1;a<e.length;a+=1)o=deepClone(e[a]),n=(l.y-o.t)*i,n>=0?(r=mergerow(l,o,t),r?(r.y=(l.y+o.y)/2,s.push(r),a+=1,l=a<e.length?deepClone(e[a]):{}):(s.push(l),l=o)):(s.push(l),l=o);return l&&s.push(l),s}function mergerow(e,t,o){let n,r,l,i=!1,s=[],a=(e.ascX,e.ascY?1:-1),g=(e.y-t.t)*a,h=Math.max(t.length,e.length);for(let o=0;o<h;o+=1){if(n=e[o]?.str,r=t[o]?.str,g=e[o]&&t[o]?(e[o].y-t[o].t)*a:void 0,n&&r){i=!1;break}l=n?e[o]:t[o],l&&s[s.length-1]&&s[s.length-1].r>l.x||g<0?i=!1:(s.push(l),i=!0)}return!!i&&s}function deepClone(e){let t=JSON.parse(JSON.stringify({...e})),o=[];for(let e in t)o[e]=t[e];return o}function getYinRow(e){return e.y}const ntoRight=(e,t,o,n,r,l)=>{let{x:i,r:s,str:a}=e;const{col:g,left:h,right:c}=t;if(i=parseFloat(i.toFixed(1)),s=parseFloat(s.toFixed(1)),h.has(i)){let t=h.get(i);return console.log(`${e.str} is found in left: ${t} shift ${t-o} from current position`),t-o}if(c.has(s)){let t=c.get(s);return console.log(`${e.str} is found in right: ${t} shift ${t-o} from current position`),t-o}if(i*n>g[o].r*n){return console.log(`${e.str} is might be on the right of cell ${o}`),findIn({col:g,i:o,x:i,r:s,dirX:n,xMin:r,xMax:l})-o}return 0},findIn=e=>{const{col:t,x:o,r:n,dirX:r,xMin:l,xMax:i}=e;let s,a,g,h,c,f,u,d,x,p,{i:m}=e,$=!1,w=!1,y=!0;do{$||(g=(o-(t[m-1]?.r??l))*r,x=Math.sign(g),u&&u*x<0?(s=m-1,$=!0,h=(o-t[s].x)*r,console.log(`difxr: ${g} and difxx: ${h} found in ${s}`)):u=x),$&&(c=((t[m+1]?.x??i)-n)*r,p=Math.sign(c),d&&d*p<0?(a=m,w=!0,f=(t[a].r-n)*r,console.log(`difrx: ${c} and difrrr: ${f} found in ${a}`)):d=p),m+=1,w&&(y=!1),m!==t.length||a||(a=m-1,y=!1)}while(y);return f=(t[a].r-n)*r,h<f?(console.log(`the result are in left difxx: ${h} < difrr: ${f}`),s):a};function arrangeCol(e,t){if(null==t)return void console.log("clr is undefined, end");const{col:o,left:n,right:r}=t;let l=e.ascX?1:-1,i=e.ascY?1:-1;e.sort(((e,t)=>e.length-t.length)),console.log("rows are sorted from smaller to larget, re-arrangment are from small to large");for(let n=0;n<e.length;n+=1)if(e[n].length!==o.length)for(let r=0;r<o.length;r+=1){if(r>e[n].length-1){console.log(`${r} are beyond rows[${n}].length-1: ${e[n].length-1}, break the loop`);break}if(void 0===e[n][r]||"na"===e[n][r]){console.log(`rows[${n}][${r}] is undefined or na, continue to next`);continue}if(""===e[n][r].str||" "===e[n][r].str){console.log(`rows[${n}][${r}] is empty string or white space, continue to next`),e[n].splice(r,1),r-=1;continue}let o=ntoRight(e[n][r],t,r,l,e.xMin,e.xMax);0!==o&&(e[n].splice(r,0,...Array(o)),console.log(`rows[${n}] is shifted ${o} to the right, re-arranged done `),r+=o-1)}else console.log("length are the same no need to re-arrange then continue to the next iteration");e.sort(((e,t)=>{let o=getYinRow(t);return(getYinRow(e)-o)*i}))}const diffXTol=-2.5;function findYinRow(e,t){for(let o=0;o<t.length;o+=1){if(Math.abs(t[o].y-e.y)<=1)return o}return"NotFound"}function joinItem(e,t){let o,n,r=t.ascX?1:-1,l=e[0],i=[];i.y=e.y,i.t=e.t;for(let t=1;t<e.length;t+=1)o=e[t],n=(l.r-o.x)*r,n>0?(l.str=l.str+o.str,l.r=l.r+o.width*r,l.width=(l.r-l.x)*r):n>-2.5?(l.str=l.str+o.str,l.r=o.r,l.width=(o.r-l.x)*r):(i.push(l),l=o);return i.push(l),i}function pushitemtorow(e,t){let o,n,r;if(0===t.length)return t[0]=[],t[0].push(e),t[0].y=e.y,void(t[0].t=e.t);o=findYinRow(e,t),"NotFound"===o?(t.push([e]),t[t.length-1].y=e.y,t[t.length-1].t=e.t):(n=t[o].ascX,r=n?1:-1,t[o].push(e),t[o].sort(((e,t)=>(t.x-e.x)*r)),t[o]=joinItem(t[o],e))}function fillcol(e,t,o){let n=[];n.xMax=t,n.xMin=o;for(let t=0;t<e.length;t+=1){let o=e[t].str;if(""===o||" "===o)continue;let r=parseFloat(e[t].x.toFixed(1)),l=parseFloat(e[t].r.toFixed(1));n.push({left:[r],x:r,r:l,right:[l]})}return n}const updatecol=(e,t,o,n,r)=>{if(void 0!==t&&0!==t.length)for(let l=0;l<e.length&&!(l>=t.length);l+=1)if("na"!==t[l]&&void 0!==t[l]){if(e[l].x!==t[l].x){let r=Math.min(e[l].x*o,t[l].x*o);if(!r){console.log(`something wrong with ${e[l]} and ${t[l]} we need to bypass this`);continue}e[l].x=r,-1===e[l].left.indexOf(r)?e[l].left.push(e[l].x):n.has(r)||(console.log(`save the new left alignment sign in ${l} with value of x: ${r} to the left Map`),n.set(r,l))}else{let o=e[l].x;t[l].x;n.has(o)||(console.log(`save the new left alignment sign in ${l} with value of x: ${o} to the left Map`),n.set(o,l))}if(e[l].r!==t[l].r&&t[l].r*o<(e?.[l+1]?.x??e.xMax)*o){let n=Math.max(e[l].r*o,t[l].r*o);if(!n){console.log(`something wrong with ${e[l]} and ${t[l]} we need to bypass this`);continue}e[l].r=n,-1===e[l].right.indexOf(n)?e[l].right.push(t[l].r):r.has(n)||(console.log(`save the new right alignment sign in ${l} with value of r: ${n} to the right Map`),r.set(n,l))}else{let o=e[l].r;t[l].r;r.has(o)||(console.log(`save the new right alignment sign in ${l} with value of r: ${o} to the right Map`),r.set(o,l))}}else console.log(`s[${l}] is undefined or has no member to evaluate or merge, continue to the next iteration`);else console.log("s is undefined or has no member to evaluate or merge, return to mergecol")},copyArrayLike=e=>{let t=[];for(let[o,n]of Object.entries(e))t[o]=n;return t};function mergecol(e,t,o,n,r){if(void 0===t||0===t.length)return console.log("shortcol is undefined or has no member to evaluate or merge, return to "),e;let l=e.length;for(let n=0;n<l;n+=1){if(n>t.length-1){console.log(`index ${n} > shortcol[i].length-1 ${t.length-1} need to break`);break}void 0!==t[n]?e[n]&&t[n].x*o>e[n].r*o?(t.splice(n,0,"na"),t.length>l&&(l=t.length,console.log("shortcol are getting longer after splice then add 1 iteration into length"))):e[n]||(e[n]=copyArrayLike(t[n]),console.log(`copying shortcol in ${n} to longcol after adjusting length of shortcol`)):console.log(`shortcol member in ${n} is undefined then continue to the next iteration`)}return updatecol(e,t,o,n,r),e}function inspectCol(e){let t=e.ascX?1:-1,o=[],n=[],r=new Map,l=new Map;e.sort(((e,t)=>t.length-e.length)),console.log("rows sorted from the longest to shortest");let i=0,s=0;for(let a=0;a<e.length;a+=1)o=fillcol(e[a],e.xMax,e.xMin),i=o.length,0!==i&&(0!==s?s>=i?(console.log(`length col1 are ${s} >= length of col0: ${i} in index: ${a} before merge process`),n=mergecol(n,o,t,r,l),console.log(`length col1 are ${n.length} >= length of col0: ${o.length} in index: ${a} after merge process`)):i>s&&(console.log(`length col1 are ${s} < length of col0: ${i} in index: ${a}before merge process`),n=mergecol(o,n,t,r,l),console.log(`length col1 are ${n.length} < length of col0: ${o.length} in index: ${a}after merge process`)):(n=copyArrayLike(o),s=i,console.log(`preparing for new pairs for col0 by copying col0 to col1 in iteration ${a}`)));return{col:n,left:r,right:l}}function _getX(e){return e&&Array.isArray(e.transform)&&e.transform[4]||-1}function _getY(e){return e&&Array.isArray(e.transform)&&e.transform[5]||-1}function parsepdf(e,t,o){let n=_getX,r=_getY;90!==t&&270!==t||(n=_getY,r=_getX);let l=0===t||90===t,i=90===t||180===t,s=[],a=[];s.ascX=l,s.ascY=i,s.xMax=a.xMax=l?o?.[2]:0,s.yMax=a.yMax=i?0:o?.[3],s.xMin=a.xMin=l?0:o?.[2],s.yMin=a.yMin=i?o?.[3]:0;for(let t of e)t.x=n(t),t.y=Math.round(r(t)),t.t=t.y+t.height*(i?-1:1),t.r=t.x+t.width*(l?1:-1),t.ascX=l,t.ascY=i,pushitemtorow(t,s);return arrangeCol(s,inspectCol(s)),checkrowdif(s,t).filter((e=>e.length>0))}async function loadPdf1(e,t,o,n,r){const l=r(await n(e));let i=await t.getDocument({data:l}),s=await i.promise,a=(s._pdfInfo.numPages,await s.getAttachments(),await s.getData(),await s.getPage(o)),g=(await s.getDestinations(),await s.getMetadata(),await s.getOutline(),await s.getPageLayout(),s.annotationStorage,await a.getTextContent()),h=a._pageInfo.rotate;return parsepdf(g.items,h,a._pageInfo.view).map((e=>e.map((e=>e?e.str:""))))}export{loadPdf1 as loadPdf};